 /**
 * This code is part of the Bumpslide Library maintained by David Knape
 * Fork me at http://github.com/tkdave/bumpslide_as3
 * 
 * Copyright (c) 2010 by Bumpslide, Inc. 
 * http://www.bumpslide.com/
 *
 * This code is released under the open-source MIT license.
 * See LICENSE.txt for full license terms.
 * More info at http://www.opensource.org/licenses/mit-license.php
 */

package com.bumpslide.util {	import com.bumpslide.data.constant.Direction;	import com.bumpslide.events.UIEvent;	import com.bumpslide.tween.FTween;	import com.bumpslide.ui.IGridItem;	import com.bumpslide.ui.IResizable;	import com.bumpslide.ui.IScrollable;	import flash.display.DisplayObject;	import flash.display.Sprite;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IEventDispatcher;	import flash.events.KeyboardEvent;	import flash.events.MouseEvent;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.ui.Keyboard;	import flash.utils.Dictionary;	import flash.utils.Timer;		/**	 * GridLayout is similar in nature to a Repeater, TileGrid, or List component.	 * 	 * GridLayout is not a display object.  You use it to populate a collection of 	 * display objects.  It takes care of attaching and updating the display objects	 * which should implement the IGridItem interface to support the passing in of	 * the 'gridItemData' and index information.	 * 	 * GridLayout needs to know only a few things:	 * 1 - What class of displayObject should be attached for each item in our 	 *     dataset (should implement IGridItem)	 * 2 - What data provider (an array or data provider [fl.data.DataProvider]) will be used to 	 *     populate this grid	 * 3 - How much space should we allocate for each column and row	 * 4 - How much space to we have to fill	 * 	 * Take a look at the gridlayout examples in the examples folder for more usage info.	 * 	 * 	 * Example:	 * <code>	 *   // sample grid item class	 *   package {	 *   import com.bumpslide.ui.GridItem;	 * 	 public class MyGridItemClass extends GridItem {	 * 	   public var label:TextField;	 * 	   override protected function drawGridItem():void {	 * 	     label.text = "Item " + gridItemData.id + ' ' + gridItemData.s;     	 * 	   }		 * 	 }	 * 	 }	 * 	 	 * 	 // then inside your view component, create a holder sprite and fill it with 	 * 	 // MyGridItemClass instances spaced 100px apart inside a space that is 300 x 300	 *   	 *   var gridHolder:Sprite = new Sprite();	 *      	 *   var grid:GridLayout = new GridLayout( gridHolder, MyGridItemClass, 100, 100);	 *   grid.setSize( 300, 300 );	 *   grid.dataProvider = [ {id:1, s:'foo'}, {id:2, s:'bar'}, {id:2, s:'foo'},	 *   					   {id:3, s:'bar'}, {id:4, s:'foo'}, {id:5, s:'bar'},	 *   					   {id:6, s:'foo'}, {id:7, s:'bar'}, {id:8, s:'foo'} ];	 *   					   	 *   addChild( gridHolder );		 *   	 *   //--	 * </code>	 * 	 * @see com.bumpslide.ui.GridItem	 * @see com.bumpslide.util.IGridItem	 * 	 * @author David Knape	 */	 	// initial layout is complete	[Event(name='complete',type="flash.events.Event")]		// rendered	[Event(name='render',type="flash.events.Event")]		// model changed	[Event(name='change',type="flash.events.Event")]		public class GridLayout extends EventDispatcher implements IScrollable, IResizable {		//--- Events ---		static public const EVENT_ITEM_CLICK:String = "itemClick";		//--- Layout/Scrolling Modes ---		static public const HORIZONTAL:String = Direction.HORIZONTAL;		static public const VERTICAL:String = Direction.VERTICAL;		// whether or not to trace debug messages		public var debugEnabled:Boolean = false;        		// how we layout clips and the direction we scroll		protected var _orientation:String = VERTICAL;				// row/column sizes		protected var _rowHeight:Number = 100;		protected var _columnWidth:Number = 100;		// number of rows and columns		protected var _rows:Number = 10;		protected var _columns:Number = 10;		// target timeline (where holder will be created)		protected var _timeline:Sprite;		// empty clip that holds items and is re-created every time we redraw		protected var _itemHolder:Sprite;			// display object class to attach (must implement IGridItem)		protected var _itemRenderer:Class;				// properties to set on items after they've been created		protected var _itemInitProperties:Object;		// dataprovider		protected var _dataProvider:*;			// array of all item clips		protected var _itemClips:Array;		// dictionary of all active clips indexed by 		protected var _activeClips:Dictionary;		// stack of un-assigned clips (to be recycled)		private var _spareClips:Array;		// height and width		protected var _width:Number = -1;		protected var _height:Number = -1;		protected var _requestedWidth:Number = 100;		protected var _requestedHeight:Number = 100;		protected var _spacing:Number = 0;		// update timer and delay		protected var _updateTimer:Timer;		protected var _updateDelay:Number = 30;		// offset and scroll state		protected var _offset:Number = 0;		protected var _indexFirst:Number = 0;		protected var _indexLast:Number = 0; 
		protected var _scrollRectOffset:Number = 0;		// misc flags		protected var _isDrawn:Boolean = false;		protected var _changedWhileSleeping:Boolean = false;		protected var _modelChanged:Boolean = false;		protected var _sleeping:Boolean = false;		protected var _sizeChanged:Boolean = false;		public var renderInBatches:Boolean = false;		public var renderBatchPageCount:Number = 3;				/**		 * Creates a new grid layout		 */		function GridLayout( inTimeline:Sprite, inItemRendererClass:Class = null, inColumnWidth:Number = 100, inRowHeight:Number = 100, inWidth:Number = -1, inHeight:Number = -1) {			_timeline = inTimeline;			_itemRenderer = inItemRendererClass;			rowHeight = inRowHeight;			columnWidth = inColumnWidth;            			reset();            			if(inWidth != -1 && inHeight != -1) {				setSize(inWidth, inHeight);			} else {
				setSize( 100, 100 );
			}		}								/** 		 * Sizes the Grid		 * 		 * this updates the column and row count		 * based on the current rowHeight and columnWidth		 */		public function setSize(w:Number, h:Number):void {		     			_requestedWidth = Math.max( w, 0 );			_requestedHeight = Math.max( h, 0 );                        			if(_width == w && _height == h) return;            			_sizeChanged = true;
						stopTweening();						// remember approximately what we were looking at			var relative_index:Number = _offset / maxOffset;			//trace( '_offset: ' + (_offset) );			//trace( 'maxOffset: ' + (maxOffset) );			//trace( 'relative_index: ' + (relative_index) );									_width = _requestedWidth;			_height = _requestedHeight; 						_rows = 1;			_columns = 1;						if(!isNaN(rowHeight) && rowHeight > 0) {				_rows = Math.max(1, (_height) / rowHeight); 				}						if(!isNaN(columnWidth) && columnWidth > 0) {				_columns = Math.max(1, (_width) / columnWidth);				}									debug('size set to ' + _width + 'x' + _height + ' rows=' + _rows + ', cols=' + _columns);									// try to match original position, but keep in bounds 			var new_offset:Number = relative_index * maxOffset;			//trace( 'new_offset: ' + (new_offset) );			offset = isNaN(new_offset) ? 0 : new_offset;						if(updateDelay > 0) updateNow();                   			// update scrollTarget to match constrained offset			_scrollTarget = _offset;		}		/**		 * Reset and destroy all children		 */			public function destroy():void {			for each (var mc:IGridItem in _itemClips) {				mc.destroy();			}			dataProvider = null; // triggers reset()		}		/**		 * Update the grid - non-destructive		 */		protected function draw():void {								// If sleeping, wait until we are awake to redraw			if(_sleeping) {				debug('Updated while sleeping , waiting to wake');				_changedWhileSleeping = true;				return;			}			_changedWhileSleeping = false;						// Make sure we have what we need (data and itemRenderer)			if(dataProvider == null /*|| dataProvider.length == 0*/ || itemRenderer == null || _itemHolder == null) {				return;			}									
			var items_per_offset_unit:Number = Math.floor((orientation == VERTICAL) ? columns : rows);
			
			var last_unit:Number;
			
			// render in batches (experimental, not always a good idea)
			if(renderInBatches) {
				var page_size:Number = Math.ceil( offsetUnitsPerPage * renderBatchPageCount );
				var first_unit:Number = Math.floor( _offset / page_size ) * page_size;
				last_unit = first_unit + page_size + offsetUnitsPerPage + 1;
				_indexFirst = first_unit * items_per_offset_unit;
				_indexLast = last_unit * items_per_offset_unit - 1;
			} else {
				// render on demand one at a time
				// (add one so fractionally visible items are included)
				last_unit = Math.ceil( _offset + offsetUnitsPerPage + 1);
				_indexFirst = Math.floor(_offset) * items_per_offset_unit;
				_indexLast = last_unit * items_per_offset_unit - 1;
			}	
			
			_indexFirst = Math.max(Math.min(_indexFirst, length - 1), 0);
			_indexLast = Math.max(Math.min(_indexLast, length - 1), 0);
			
			debug('Updating to offset ' + _offset + ' (showing items ' + indexFirst + '-' + indexLast + ' of ' + length + ') (minOffset:' + minOffset + ', maxOffset:' + maxOffset + ')');			
			// there is a limit to how high x can be (int.MAX_VALUE/20)
			// we need to shift the scrollRect and move items accordingly
			
			// When this happens, all active clips are moved and the scrollRect is shifted
			// this causes rollover states and mouse hand cursors to flciker when items are buttons
			// it also makes for a stutter in animation. 
			
			// This is how often (in pixels) the scrollRect offset will change
			var max_x:Number = 1E6;
			var px_per_offset:Number = (orientation == HORIZONTAL) ? columnWidth : rowHeight;
			var offset_page_size:Number = Math.floor( max_x / px_per_offset );
			
			_scrollRectOffset = Math.floor( _offset / offset_page_size ) * offset_page_size;
						// update scroll rect			var scroll_rect:Rectangle = null;
						if(_width > 0 && _height > 0 && totalSize > visibleSize) {	            				// offset main holder to simulate "scrolling"				scroll_rect = new Rectangle(0, 0, _width, _height);								if(orientation == HORIZONTAL) {	            						scroll_rect.x = (columnWidth * (_offset - _scrollRectOffset)); 				} else {					scroll_rect.y = (rowHeight * (_offset - _scrollRectOffset));				}		            				_itemHolder.scrollRect = scroll_rect;			}  else {				_itemHolder.scrollRect = null;			}						// recycle any active clips that are no longer in use			recycleUnusedItems();									var mc:IGridItem;						if(length) for( var n:Number = indexFirst;n <= _indexLast; n++) {								//debug('doUpdate item' + n);								// look for MC already assigned to this index and update its position				mc = _activeClips[n];								if(mc == null) {							// create new grid item (pull from stack of latent clips if there are some)					mc = getItemClip();					// update the item with proper data					updateItem(mc, n);						_itemHolder.addChild(mc as DisplayObject);				} else {											// If this was triggered by a model change, check to see if 					// data has changed for this item index							if(_modelChanged && mc.gridItemData != getDataForItem(n)) {						//debug('updating exisiting clip (' + mc.gridIndex + '->' + n + ')');						updateItem(mc, n);					} else {						//debug('moving exisiting clip (' + mc.gridIndex + ')');
						var pos:Point = calculateItemPosition(n);						//if(mc.x!=pos.x) 
						mc.x = pos.x;						//if(mc.y!=pos.y) 
						mc.y = pos.y;     						if(_sizeChanged && mc is IResizable) {							(mc as IResizable).setSize(columnWidth - _spacing, rowHeight - _spacing);						}   					}									}			}								if(!_isDrawn) {				_isDrawn = true;				dispatchEvent( new Event(Event.COMPLETE));			}						if(_modelChanged) {				_modelChanged = false;					dispatchEvent( new Event( Event.CHANGE ) );			}
			
			_sizeChanged = false;						dispatchEvent( new Event( Event.RENDER) );		}		/**		 * put grid to sleep, grid won't respond to changes until awakened		 */		public function sleep():void {			debug('sleep');			_sleeping = true;		}		/**		 * brings grid back to life, updates it if something has changed while we were sleeping		 */		public function wake():void {				debug('wake');			_sleeping = false;			if(_changedWhileSleeping) updateNow();		}		/**		 * Clear items and reset		 */		public function reset():void {			            			Delegate.cancel(_updateTimer);			stopTweening();			_scrollTarget = 0;			_sleeping = false;			_changedWhileSleeping = false;			_isDrawn = false;            			if( _itemHolder != null && _timeline.contains(_itemHolder)) {				_timeline.removeChild(_itemHolder);				_itemHolder.removeEventListener(MouseEvent.CLICK, handleItemClickOrKeyPress);				_itemHolder.removeEventListener(KeyboardEvent.KEY_DOWN, handleItemClickOrKeyPress);			}			_itemHolder = new Sprite();	
			//_itemHolder.cacheAsBitmap = true;	// we are better off bitmap caching individual cells				_itemHolder.addEventListener(MouseEvent.CLICK, handleItemClickOrKeyPress, false, 0, true);			_itemHolder.addEventListener(KeyboardEvent.KEY_DOWN, handleItemClickOrKeyPress, false, 0, true);			_timeline.addChild(_itemHolder);				_itemClips = new Array();			_spareClips = new Array();   			_activeClips = new Dictionary();								if(_dataProvider && _dataProvider is IEventDispatcher) {				var ed:IEventDispatcher = dataProvider as IEventDispatcher;				// listen for fl.data.DataProvider and mx.collections.ArrayCollection change events				ed.removeEventListener('dataChange', onDataChange);				ed.removeEventListener('collectionChange', onCollectionChange );			}						_dataProvider = null;
			_scrollRectOffset = 0;			_offset = 0;						invalidate();		}		public function stopTweening():void {			FTween.stopTweening(this, 'offset');		}		private function handleItemClickOrKeyPress(event:Event):void {			if(event.target is IGridItem && (!(event is KeyboardEvent) || (event as KeyboardEvent).keyCode==Keyboard.ENTER)) {				var item:IGridItem = event.target as IGridItem;				UIEvent.send(event.target as DisplayObject, EVENT_ITEM_CLICK, item.gridItemData);			}		}				public function updateNow(e:Event = null):void {			Delegate.cancel(_updateTimer);
			
			// constrain offset
			_offset = Math.max(minOffset, Math.min(maxOffset, _offset));
													
			//debug('offset constrained to ' + _offset);
			
			
						draw();		}		/**		 * Returns the display object for the given index or null if it is not rendered		 */		public function getGridItemAt( idx:Number ):IGridItem {			var item:IGridItem = _activeClips[idx];			return item;		}		/**		 * Handles fl.data.DataProvider change events		 * 		 * note, we don't explicity reference the flash dataprovider to keep this code portable		 */		protected function onDataChange(e:Event):void {			_modelChanged = true;			debug('onDataChange ' + e['changeType']);						// if items are removed from the middle, we want to keep the remaining 			// items bound to the same data.  
			
			// fl.events.DataChangeType.REMOVE			if( e['changeType'] == 'remove') {				
				// items from startIndex to endIndex (inclusive) should be removed
				// any items that come after those should have their offset index adjusted
				
				// get start and end index from the change event 
				// This should be an event of type DataChangeType.REMOVE				var startIndex:Number = e['startIndex'];				var endIndex:Number = e['endIndex'];				var count:Number = endIndex - startIndex + 1;
								// trash all clips clips from startIndex to endIndex inclusive				for(var n:Number = startIndex;n <= endIndex; n++) {					recycleItem(n);				}
				
				// since we are removing items, update affected indexes before we invalidate 
				// so that item data stays tied to the same items
				var altered_items:Array = [];
				var item:IGridItem;
				for each (item in _activeClips) {
					var i:Number = item.gridIndex;
					if(i>endIndex) {
						item = _activeClips[i] as IGridItem;
						//trace('moving item from index ' + i + ' to index ' + (item.gridIndex-count));
						delete _activeClips[item.gridIndex];
						item.gridIndex -= count;
						altered_items.push( item );
					}
				}
				
				for each (item in altered_items) {
					_activeClips[item.gridIndex] = item;
				}			}			invalidate();		}				/**		 * Handle ArrayCollection (flex) collection change events		 */		protected function onCollectionChange(e:Event):void {			_modelChanged = true;			invalidate();		}		/**		 * Schedules an update after a slight delay		 */		protected function invalidate():void {						// update after delay			Delegate.cancel(_updateTimer);				if(updateDelay > 0) { 				_updateTimer = Delegate.callLater(updateDelay, updateNow);			} else {				updateNow();			}		}		/**		 * Checks to see if an item instance is used in the current view.  		 * 		 * If no longer needed, the clip is removed from the display list and 		 * added to the list of spare clips where it can be re-used later.		 */		protected function recycleUnusedItems():void {						for each( var item:IGridItem in _activeClips ) {								if(( item.gridIndex < indexFirst || item.gridIndex > indexLast || length == 0 ) ) {					recycleItem(item.gridIndex);				}			}		}		/**		 * Recycles an individual grid item		 */		protected function recycleItem(idx:Number):void {			var item:IGridItem = _activeClips[ idx ] as IGridItem;
			if(item==null || ! _itemHolder.contains(item as DisplayObject)) return;			debug('recycling clip ' + item.gridItemData);			delete _activeClips[idx];			//_activeClips.splice( idx, 1);              			item.gridIndex = Number.NaN;			item.gridItemData = null;			_itemHolder.removeChild(item as DisplayObject);			_spareClips.push(item);		}		/**		 * Get spare item clip or create a new one		 */		protected function getItemClip():IGridItem {			var item:IGridItem;            			if(itemRenderer == null) {				throw new Error("Unabled to return an item renderer when the itemRendererClass is null");				return null;			}			// If we have some spare, unused clips, use them 			if(!_spareClips.length) { 				item = ObjectUtil.create( itemRenderer, itemInitProperties);				if(item == null) {					throw new Error("Invalid Item Renderer - " + itemRenderer + " (possibly not an IGridItem)");					return null;				}				debug('created new clip ' + item['name']);				// hold on to this for future use				_itemClips.push(item); 			} else {	                						item = _spareClips.pop() as IGridItem;				debug('re-using old clip ' + item['name']);				}					return item;		}				protected function updateItem( item:IGridItem, idx:Number ):void {				debug('update item ' + idx + ' ' + item);	                        try {            	item['layout'] = this; // if item needs reference to layout, update it             } catch(e:Error) {};            			item.gridIndex = idx;			item.gridItemData = getDataForItem(idx);                        				var pos:Point = calculateItemPosition(idx);			item.x = pos.x;			item.y = pos.y;		            			if(item is IResizable) {				(item as IResizable).setSize(columnWidth - _spacing, rowHeight - _spacing);			}			//mClipMap['_'+idx] = item;			_activeClips[idx] = item;					}		protected function getDataForItem(idx:Number):* {			return dataProvider.getItemAt != undefined ? dataProvider.getItemAt(idx) : dataProvider[idx];		}		/**		 * Calculated the x and y pos for the grid item at index n		 * 		 * @param	i		 * @return x,y location as point		 */		protected function calculateItemPosition( n:Number ):Point {								var i:Number = n - _scrollRectOffset;			var column:Number;			var row:Number;								// calculate grid index (column and row)			if(orientation == HORIZONTAL) {				row = i % Math.floor(rows);				column = rows > 0 ? Math.floor(i / Math.floor(rows)) : 0;					} else {				column = i % Math.floor(columns);				row = columns > 0 ? Math.floor(i / Math.floor(columns)) : 0;					}						return new Point((columnWidth * column), (rowHeight * row));		}		/**		 * Debug/trace		 */		private function debug(s:*):void {			if(debugEnabled) trace('[GridLayout] ' + s);		}		//-------------------------------------		// GETTERS/SETTERS		//-------------------------------------				/**		 * array of references to all the grid item MovieClips currently being rendered		 * items are sorted by their index position		 */		public function get itemClips():Array {			var a:Array = new Array();			for each (var item:IGridItem in _activeClips) {				a.push(item);			}			a.sortOn('gridIndex', Array.NUMERIC);			return a;		}		/**		 * an array of arrays of item clips sorted by row		 */		public function get itemClipsByRow():Array {			var a:Array = new Array();        				for(var n:Number = indexFirst;n <= indexLast; n++) {				var row:Number = calculateItemPosition(n).y / rowHeight;				if(a[row] == null) a[row] = new Array();				if(_activeClips[n] != null) {					a[row].push(_activeClips[n]);				}			}			return a;		}		/**		 * an array of arrays of item clips sorted by column		 */		public function get itemClipsByColumn():Array {			var a:Array = new Array();        				for(var n:Number = indexFirst;n <= indexLast; n++) {				var col:Number = calculateItemPosition(n).x / columnWidth;				if(a[col] == null) a[col] = new Array();				if(_activeClips[n] != null) {					a[col].push(_activeClips[n]);				}			}			return a;		}		/**		 * An array or fl.data.DataProvider		 * 		 * @return array of item data		 */		public function get dataProvider():* {			return _dataProvider;		}		/**		 * Sets the data provider for the grid		 *  		 * @param data Array or fl.data.DataProvider		 */		public function set dataProvider( dp:* ):void {        				reset();        				if(dp == null) {				debug('dataProvider is null');				return;			}        				_dataProvider = dp;									if(dp is IEventDispatcher) {				var ed:IEventDispatcher = dp as IEventDispatcher;				ed.addEventListener('dataChange', onDataChange);		
				ed.addEventListener('collectionChange', onCollectionChange );					}									debug('setting dataProvider, length=' + dataProvider.length);												invalidate();		}		/**		 * returns length of the dataprovider (total number of items in grid)		 * @return		 */		public function get length():Number {			if(dataProvider != null) return dataProvider.length;			else return 0;		}		/**		 * returns reference to timeline		 * @return		 */		public function get timeline():DisplayObject {			return _timeline;		}		/**		 * Where the items are located		 */		public function get itemHolder():Sprite {			return _itemHolder;		}		/**		 * offset in dataprovider (index of first item in the grid)		 * 		 * @param	n		 */		public function get offset():Number {			return _offset;		}		/**		 * offset in dataprovider (index of first item in the grid)		 * 		 * @param	n		 */		public function set offset( inOffset:Number ):void {						if(isNaN(inOffset)) {				//throw new Error('Offset cannot be set to ' + inOffset );				//debug('ERROR - offset cannot be set to ' + inOffset);				return;			}					debug('offset set to ' + inOffset);					_offset = inOffset;			               			invalidate();		}		/**		 * Rows or Columns per page		 */		public function get offsetUnitsPerPage():Number {			if(orientation == VERTICAL) {				return Math.floor(rows);			} else {				return Math.floor(columns);			}		}		/**		 * Returns the total number of pages 		 * 		 * This is calculated using the  current dataprovider and the number of items per page		 * 		 * This is useful for displaying page info in controls and things like that.		 * 		 * @return		 */		public function get totalPages():Number {					return Math.ceil(length / offsetUnitsPerPage);		}		/**		 * Minimum scroll offset		 */		public function get minOffset():Number {					return 0;		}		/**		 * Maximum scroll offset		 */		public function get maxOffset():Number {					if (dataProvider == null || dataProvider.length == 0) {				return 0;			} else {				return totalSize - visibleSize;			}		}		/**		 * Zero-index page number based on current offset		 */		public function get page():Number {			return Math.floor(offset / offsetUnitsPerPage);		}		/**		 * sets the page number (0 is first page)		 */		public function set page( num:Number ):void {					scrollPosition = offsetUnitsPerPage * num;		}		/**		 * go to the next page		 */		public function pageNext():void {			debug('pageNext()');			scrollPosition += offsetUnitsPerPage;		}		/**		 * go to the previous page		 */		public function pagePrevious():void {			debug('pagePrevious()');			scrollPosition -= offsetUnitsPerPage;		}		/**		 * delay before updates		 */		public function get updateDelay():Number {			return _updateDelay;		}		/**		 * delay before updates		 */		public function set updateDelay(updateDelay:Number):void {			_updateDelay = updateDelay;		}		/**		 * index of first child item being rendered		 */		public function get indexFirst():Number {			return _indexFirst;		}		/**		 * index of last child item being rendered
		 * 
		 * Note that this may or may not be visible.		 */		public function get indexLast():Number {			return _indexLast;		}		/**		 * the class that will be used to construct child items		 */		public function get itemRenderer():Class {			return _itemRenderer;		}		/**		 * the class that will be used to construct child items		 */		public function set itemRenderer(itemRenderer:Class):void {			debug('Item renderer changed to ' + itemRenderer );			_itemRenderer = itemRenderer;			destroy();			updateNow();		}						public function get itemInitProperties():Object {			return _itemInitProperties;		}				public function set itemInitProperties(itemInitProperties:Object):void {			_itemInitProperties = itemInitProperties;		}		public function get rowHeight():Number {			return _rowHeight;		}		public function set rowHeight(rowHeight:Number):void {			if(rowHeight==_rowHeight) return;
			_rowHeight = rowHeight;
			_sizeChanged = true;			invalidate();		}		public function get columnWidth():Number {			return _columnWidth;		}		public function set columnWidth(columnWidth:Number):void {
			if(columnWidth==_columnWidth) return;			_columnWidth = columnWidth;
			_sizeChanged = true;			invalidate();		}		public function get orientation():String {			return _orientation;		}		public function set orientation(direction:String):void {			_orientation = direction;			invalidate();			// invalidate size			//setSize(_requestedWidth, _requestedHeight);		}				public function get rows():Number {			return _rows;		}		public function set rows(rows:Number):void {			_rows = rows;		}		public function get columns():Number {			return _columns;		}		public function set columns(columns:Number):void {			_columns = columns;		}		public function get spacing():Number {			return _spacing;		}		public function set spacing(spacing:Number):void {			_spacing = spacing;			//setSize(_requestedWidth, _requestedHeight);		}				//----------------------------		// IScrollable Implementation		//----------------------------		private var _scrollTarget:Number = 0;		public var tweeningEnabled:Boolean = true;		public var scrollTweenEaseFactor:Number = .3;		// total size - measured in terms of rows or columns		public function get totalSize():Number {			if(length == 0) return 0;			if(orientation == VERTICAL) {				// total number of rows (round up to show whole row)				return Math.ceil(length / columns) - spacing / rowHeight;			} else {				// total number of columns (round up to show whole column)				return Math.ceil(length / rows) - spacing / columnWidth;			}		}		public function get visibleSize():Number {			return (orientation == VERTICAL) ? rows : columns;		}		public function get scrollPosition():Number {			return _scrollTarget;		}		/**		 * Scroll position indexed by row or column (oritentation vert, horiz respectively)		 */		public function set scrollPosition(scrollOffset:Number):void {						// instant updates if we are scrolling			updateDelay = 0;						_scrollTarget = Math.max(Math.min(scrollOffset, maxOffset), minOffset);						if(tweeningEnabled) {				FTween.ease(this, 'offset', _scrollTarget, scrollTweenEaseFactor, {minDelta: .01});			} else {				stopTweening();				offset = _scrollTarget;			}		}				public function get width():Number {			return _width;		}				public function set width( w:Number ):void {			setSize( w, height );		}						public function get height():Number {			return _height;		}						public function set height(h:Number):void {			setSize( width, h );		}		public function get scrollRectOffset():Number {			return _scrollRectOffset;		}			public function get pixelsPerUnit():Number {			return (orientation==Direction.HORIZONTAL) ? columnWidth : rowHeight;
		}		
			}}